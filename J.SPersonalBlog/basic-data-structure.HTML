<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="stylesheet" href="style.CSS">
    <title>J.SPersonalBlog</title>
</head>

<body>
    <header>
        <h1 class="titulo">Estructura de datos básicas</h1>
        <nav>
            <a href="basic-javascript.HTML" class="enlace-barra-nav">Volver al principio</a>
        </nav>
    </header>
    <main>
        <h2>¿Qué son las estructuras de datos básicas?</h2>
        <div class="principio">
            <img src="BDS1.jpg" alt="basic-data-structure-logo">
            <p class="definicion">Las estructuras de datos básicas(Arrays y Objetos) son maneras en las que podemos
                guardar elementos en la computadora,de esta forma podemos acceder,crear y eliminar datos de forma
                eficiente.Ademas podemos usar metodos como objectKeys() y .splice() para acceder y manipular los datos
                almacenados.</p>
        </div>
        <div id="basic-data-structure">
            <h2>Utilice una matriz para almacenar una colección de datos</h2>
            <p>Como ya sabemos,podemos almacenar diferentes tipos de datos dentro de una matriz multidimensional o una
                unidimensional:</p>
            <pre>
    <code>
    //Matriz unidimensional:
    let firstArray = ['one', false, undefined, "", 100];
    console.log(firstArray);
    //Matriz multidimensional:
    let secondArray = [
    [
      {
      x: "X";
      y: "Y"
      },
      {
      w: "W",
      z: "Z"
      }
    ],
    [
      {
      1: "one",
      2: "two"
      },
      {
      3: "three",
      4: "four" 
      }
    ]
    ]
    ];
    console.log(secondArray);//Esta llamada devuelve: {1: "one", 2: "two"}
    </code>
    </pre>
            <h2>Acceder al contenido de una matriz usando la notación entre corchetes</h2>
            <p>Para poder acceder al contenido de una matriz podemos usar la notación de corchetes:</p>
            <pre>
    <code>
    let numbersArray = [1, 100, 3, 4, 5];
    numbersArray[1] = "two";
    console.log(numbersArray);
    //Devuelve: [1, 'two', 3, 4, 5],también podemos asignarle a una var como valor una parte del arreglo:
    let string = numbersArray[1];
    //Ahora string tiene de valor two
    </code>
    </pre>
            <h2>Agregar elementos a una matriz con .push() y .unshift()</h2>
            <p>Como ya sabemos,las matrices son mutables(se le pueden agregar/quitar elementos):</p>
            <pre>
    <code>
    let string1 = "XX";
    let string2 = [8, 9];
    string2.unshift('VI', 7);
    string2.push(string1);
    //En el caso de quisieramos pasarle una matriz como argumento a una función:
    function count(string) {
    string.unshift(1, 'two', "three");
    string.push("VI", 'VII', 8);
    return string;
    }
    console.log(count([4, 5]));
    //Aquí devuelve: [1, 'two', 'three', 4, 5, 'VI', 'VII', 8] 
    </code>
    </pre>
            <h2>Eliminar elementos de una matriz con .pop() y .shift()</h2>
            <p>En este caso,si quisieramos remover el primer y último elemento de una matriz tendríamos que usar .pop()
                y .shift():</p>
            <pre>
    <code>
    let saludo = ["que", "onda", "pa"];
    saludo.pop();
    saludo.shift();
    //También podemos asignarle el valor eliminado a una variable:
    let guardar = saludo.pop();
    //En este caso saludo sería igual a [] y guardar sería "onda".Por último,si los usaramos en una función:
    function usarPopShift(arr) {
    let pop = arr.pop();
    let shift = arr.shift();
    return [shift, pop];
    }
    console.log(usarPopShift(['shift', 'nothing', 'nothing', 'pop']));
    //Esto nos devuelve: ['shift', 'pop']
    </code>
    </pre>
            <h2>Eliminar elementos usando .splice()</h2>
            <p>Si quisieramos eliminar cualquier número de elementos consecutivos de cualquier matriz,debemos usar
                .splice().Este puede tomar 3 parametros,el primero representa el índice de la matriz desde la cual
                comenzar a eliminar elementos,el segundo ínidica el número de elementos a eliminar:</p>
            <pre>
    <code>
    let string = ['que', 'onda', 'capo', 'todo', 'bien'];
    string.splice(2, 2);
    /*Aquí estamos eliminando 2 elementos comenzando con el tercer elemento(en el índice 2).Ahora string tiene de valor ['que', 'onda', 'bien'].
    También podemos asignarle los valores eliminados a una var:*/
    let string = ['que', 'onda', 'pa', 'todo', 'bien'];
    let string2 = string.splice(2, 2);
    //Ahora string2 es igual a: ['pa', 'todo'].También podemos usar varios .splice():
    const numbers = [1, 2, 3, 4, 5, 6, 7, 8];
    numbers.splice(0, 2);
    numbers.splice(1, 2);
    numbers.splice(2, 2);
    console.log(numbers);
    //Aquí eliminamos: 1,2,4,5,7,8 solo quedando [3, 6];
    </code>
    </pre>
            <h2>Agregar elementos usando .splice()</h2>
            <p>Retomando el tema anterior,el tercer parametro de .splice() nos permite agregar elementos a la matriz:
            </p>
            <pre>
    <code>
    const numbersArray = [10, 20, 30, 30, 60];
    const index = 3;
    const remove = 1;
    numbersArray.splice(index, remove, 40, 50);
    console.log(numbersArray);
    //Esta llamada nos devolvería: [10, 20, 30, 40, 50, 60] siendo este arreglo el nuevo valor de numbersArray.
    </code>
    </pre>
            <h2>Copiar elementos de matriz usando .slice()</h2>
            <p>El método .slice() nos permite copiar/extraer una cantidad determinadaa de elementos a una nueva matriz,sin modificar la matriz original:</p>
            <pre>
    <code>
    let originalArray = ['one', 'two, 'three', 'four', 'five'];
    let newArray = originalArray.slice(1, 3);
    /*Aquí originalArray mantiene su arreglo y ahora newArray tiene de valor: ['two', 'three'].La extración no incluira el elemento perteneciente al
    último índice de .slice(),por eso no figura en newArray "four"*/
    </code>
    </pre>
            <h2>Copiar una matriz con el operador spread</h2>
            <p>En el caso de que quisieramos todos los elementos de una matriz,podemos copiarlos usando el operador
                spread:</p>
            <pre>
    <code>
    let valores1 = [undefined, true, false, null, NaN];
    let valores2 = [...valores2];
    //Ahora valores2 tiene de valor el mismo arreglo que valores1.Si lo usaramos en una función:
    function copy(arr, num) {
    let newArr = [];
    while(num >= 1) {
    newArr.push([...arr]);
    num--;
    }
    return newArr;
    }
    console.log(copy([NaN, undefined, null], 3));
    //El número que pongamos va a indicar la cantidad de veces que se le asignara el valor de arr a newArr.
    </code>
    </pre>
            <h2>Combinar matrices con el operador spread</h2>
            <p>Otra ventaja del operado spread es que nos permite combinar matrices/insertar elementos de una matriz a
                otra en cualquier índice:</p>
            <pre>
    <code>
    let example1 = ["tres", "cuatro", "cinco", "seis"];
    let example2 = ["uno", "dos", ...example1, "siete"];
    //Ahora example2 tiene de valor ['uno', 'dos', 'tres', 'cuatro', 'cinco', 'seis', 'siete'].Si lo usaramos en una función:
    function example3() {
    let example1 = ["tres", "cuatro", "cinco", "seis"];
    let example2 = ["uno", "dos", ...example1, "siete"];
    return example2;
    }
    console.log(examole3());
    </code>
    </pre>
            <h2>Compruebe la presencia de un elemento con .indexOf()</h2>
            <p>El metodo .indexOf() sirve para cpmprobar rápida y facilmente la presencia de un elemento en una
                matriz,este metodo toma un elemento como parámetro y ccuando se llama,devuelve la posición/índice de ese
                elemento,si el elemento mo existe en la matriz devuelve -1:</p>
            <pre>
    <code>
    let alimentos = ['frutas', 'pastas', 'verduras', 'lacteos'];
    console.log(alimentos.indexOf('bebidas'));
    console.log(alimentos.indexOf('frutas'));
    console.log(alimentos.indexOf('verduras'));
    console.log(alimentos.indexOf('lacteos'));
    //La primera llamada devuelve -1,la segunda 0,la tercera 2 y la cuarta 3.
    </code>
    </pre>
            <h2>Iterar a través de todos los elementos de una matriz usando bucles for</h2>
            <p>Cuando trabajamos con matrices,a veces resulta útil iterar cada elemento para encontrar uno o más
                elementos que lleguemos a necesitar o manipular una matriz en función de que elementos de datos cumplen
                con un conjunto de criterios</p>
            <pre>
    <code>
    function filteredArray(arr, elem) {
    let newArr = [];
    for(let a = 0; a &lt arr.length; a++) {
    if(arr[a].indexOf(elem) == - 1) {
    newArr.push(arr[a]);
    }
    }
    return newArr;
    } 
    console.log(filteredArray([[1, 2, 1], [1, 6, 3], [1, 13, 26], [19, 1, 9]], 3));
    //Aquí nos devuelve una nueva matriz anidada que solo contiene las matrices que no tengan el elem 3
    </code>
    </pre>
            <h2>Crear matrices multidimensionales complejas</h2>
            <p>Las matrices pueden tener una infinita profundidad de matrices que pueden contener otras
                matrices,teniendo cada una sus propios niveles,y así infinitamente.Es así como una matriz se convierte
                en una estructura de datos compleja(una matriz multidimensional o anidada):</p>
            <pre>
    <code>
    let arreglosAnidados = [
    ['unshift', false],
    [
     [true, 'array']
    ],
    [
     [
       ['splice', 7]
     ],
     [
       [
         [100]
       ]
     ] 
    ]
    ];
    console.log(arreglosAnidados[2][1]);// esto es igual a: [[[100]]],si pusieramos [2][1][0] = [[100]],[2][1][0][0] = [100] y [2][1][0][0][0] = 100
    </code>
    </pre>
            <h2>Agregar pares clave-valor a objetos en J.S</h2>
            <p>Los objetos son solo colecciones de oares clave-valor,es decir,son piezas de datos(valores) asignados a
                identificadores únicos llamados propiedades(claves):</p>
            <pre>
    <code>
    const comidas = {
    naranjas: 10,
    peras: 6,
    manzanas: 9,
    bananas: 5
    };
    comidas.duraznos = 4;
    comidas.mangos = 5;
    comidas['frutos secos'] = 15;
    console.log(comidas);
    //Ahora al llamar al objeto,este incluira las nuevas clave-valor que le asignamos
    </code>
    </pre>
            <h2>Modificar un objeto anidado dentro de un objeto</h2>
            <p>Dentro de los objetos podemos tener matrices,otros onjetos o cualquier otro tipo de dato valido en J.S,a
                estos mismos se les puede asignar nuevos valores a sus claves:</p>
            <pre>
    <code>
    let usuario = {
    id: 0124382,
    registrado: "17/12/19";
    informacion: {
    sexo: 'Masculino',
    nombre: 'Osvaldo'
    }
    };
    usuario['informacion'].nombre = 'Miguel';
    console.log(usuario);
    //Aquí le reaccinamos el valor a la propiedad(clave) nombre
    </code>
    </pre>
            <h2>Acceder a los nombres de propiedades con la notación de corchetes</h2>
            <p>La notacón de corchetes nos puede ser útil cuando no conocemos las propiedades de los objetos a las que
                queremos utilizar,permitiendonos acceder a ellas de una manera más dinámica:</p>
            <pre>
    <code>
    let compras = {
    manzanas: 10,
    carne: "Tapa de azado",
    bolsaDePapas: 1,
    consimento: "Pimienta negra"
    };
    function listaDeCompras(comestibles) {
    return compras[comestibles];
    };
    console.log(listaDeCompras("condimento"));
    </code>
    </pre>
            <h2>Usar "delete" para eliminar las propiedades de los objetos</h2>
            <p>En caso de que quisieramos eliminar claves-valor de un objeto tenemos que usar la palabra clave "delete":
            </p>
            <pre>
    <code>
    delete compras.manzanas;
    delete compras.carne;
    delete compras['condimento'];
    </code>
    </pre>
            <h2>Evaluar si un objeto contiene una propiedad</h2>
            <p>En caso de que quisieramos comprobar si un objeto tiene una propiedad en específico,podemos usar los
                métodos: .hasOwnProperty() o in:</p>
            <pre>
    <code>
    let clientes = {
    Gomes: {
    activo: true,
    registrado: '01/04/12'
    },
    Marcelo: {
    activo: false,
    registrado: '19/02/14'
    },
    Papo: {
    activo: true,
    registrado: '10/07/17'
    }
    };
    function verificarUsers(user) {
    return 'Gomes' in user && 'Marcelo' in user && 'Papo' in user;
    }
    console.log(verificarUsers(clientes));
    //En caso de que usaramos el otro método:
    user.hasOwnProperty('Marcelo')
    //Básicamente escribimos lo mismo que el ejemplo de in,pero con este método 
    </code>
    </pre>
            <h2>Iterar mediante las claves de un objeto con la sentencia for...in</h2>
            <p>Si necesitamos iterar todas las claves de un objeto podemos usar un bucle for...in para lograrlo:</p>
            <pre>
    <code>
    const object = {
    Pepito: {
    online: true
    },
    Jaimito: {
    online: false
    },
    Perro: {
    online: false
    }
    };
    for(let people in object) {
    console.log(people, object[people]);
    }
    //Si lo usaramos en una función:
    function countPlayers(users) {
    let final = 0;
    for(let obj in users) {
    if(users[obj].online == true) {
    final++;
    }
    }
    return final
    }
    console.log(verificarUsers(object));
    </code>
    </pre>
            <h2>Generar un arreglo con todas las claves de un objeto usando Object.keys()</h2>
            <p>La función de Object.keys() es generar un arreglo que tendrá todas las claves almacenadas en un
                objeto.Dentro de los parentesis de este método escribimos el nombre del objecto como argumento:</p>
            <pre>
    <code>
    let family = {
    John: {
    character: "Son"
    },
    Mike: {
    character: "Father"
    },
    Mariana: {
    character: "Mather"
    }
    };
    let result = Object.keys(family);
    console.log(result);
    function myFamily(member) {
    return Object.keys(member);
    }
    console.log(myFamily(family));
    //Tanto la llamada de la función y la del result devuelven: ['John', 'Mike', 'Mariana']
    </code>
    </pre>
        </div>
    </main>
    <footer>
        <h3 id="titulo-footer">Contactos:</h3>
        <div class="contactos">
            <p class="texto-final">Instragram: Fraaan.g_m</p>
            <p class="texto-final">Gmail: fgmanuello1@gmail.com</p>
            <p class="texto-final">GitHub: Francisco-G-M</p>
        </div>
    </footer>
</body>

</html>