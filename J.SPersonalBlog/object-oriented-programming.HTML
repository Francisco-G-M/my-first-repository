<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="stylesheet" href="style.CSS">
    <title>J.SPersonalBlog</title>
</head>

<body>
    <header>
        <h1 class="titulo">Programación orientada a objetos</h1>
        <nav>
            <a href="basic-javascript.HTML" class="enlace-barra-nav">volver al principio</a>
        </nav>
    </header>
    <main>
        <h1>¿Qué es la progrmación orientada a objetos?</h1>
        <div class="principio">
            <img src="OOP1.jpeg" alt="object-oriented-programming">
            <p class="definicion">La OOP (progrmación orientada a objetos) es un modelo de programación en el cual se
                utilizan los objetos
                y
                las clases para organizar el código,buscando que este sea reutilizable,organizado y sencillo de
                mantener.Este modelo sigue el principio de desarrollo de sofware DRY (Don't Repeat Yourself),que como
                dice su nombre consiste en no duplicar el código.</p>
        </div>

        <div id="object-oriented-programming">
            <h2>Definir una función "constructor"</h2>
            <p>Este tipo de funciones crean nuevos objetos que definen propiedades y comportamientos para el nuevo
                objeto:</p>
            <pre>
    <code>
    function Character() {
    this.name = "Scoby-Duu";
    this.color = "Brown";
    }            
    </code>
    </pre>
            <p>Los constructores siguen las siguientes convenciones:</p>
            <ul>
                <li>-Se definen con un nombre en mayúscula para distinguirlos de otras funciones que no sean
                    constructores.</li>
                <li>-Utilizan la clave "this" para establecer propiedades del objeto que se crea.Dentro de esta función
                    "this" se refiere al nuevo objeto.</li>
                <li>-Los constructores definen propiedades y comportamientos,a diferencia de las funciones que devuelven
                    un valor.</li>
            </ul>
            <p>Si queremos asignar el constructor a una variable:</p>
            <pre>
    <code>
    let otherCharacter = new Character();
    </code>
    </pre>
            <p>El operador "new" se utiliza para llamar a un constructor,le índica a J.S que cree una nueva instancia de
                Character llamada otherCharacter,si no usaramos "new" dentro del constructor "this" no haría referencia
                al nuevo objeto.Ahora otherCharacter tiene todas las propiedades del constructor,pudiendo nosotros
                acceder y modificar este nuevo objeto:</p>
            <pre>
    <code>
    otherCharacter.name = "BigBoy";
    </code>
    </pre>
            <h2>constructor con argumentos</h2>
            <p>La función de los parametros en los constructores es volverlos más flexibles,pudiendo definir las
                propiedades de cada nuevo objeto en el momento que se crea:</p>
            <pre>
   <code>
   function Dog(name, color) {
   this.name = name;
   this.color = color;
   this.legs = 4;
   }
   let goldenTerrier = new Dog("BigBoy", "Golden");
   </code>
   </pre>
            <h2>Verificar el constructor de un objeto con "instanceof"</h2>
            <p>La función de "instanceof" es verificar la instancia de un objeto de un determinado
                constructor,básicamente compara un objeto con un constructor,devolviendo true o false si el objeto fue
                creado/o no con ese constructor:</p>
            <pre>
   <code>
   function Propiedad(numberOfHouse) {
   this.numberOfHouse = numberOfHouse;
   }
   let miPropiedad = new Propiedad(17);
   miPropiedad instanceof Propiedad;
   //Esto devuelve true,támbien podemos llamarlo con un console.log():
   console.log(miPropiedad instanceof Propiedad);
   //támbien devuelve true
   </code>
   </pre>
            <h2>Propiedades directas</h2>
            <p>Denominados propiedades directas a todo aquello definido en la instancia de un objeto,e.j:</p>
            <pre>
   <code>
   function Perro(nombre) {
   this.nombre = nombre;
   this.patas = 4;
   } 
   let caniche = new Perro("Limon");
   let arrayDog = [];
   for(let agregar in caniche) {
   if(agregar in caniche) {
   arrayDog.push(agregar);
   }
   }
   console.log(arrayDog);
   //Aquí nos devuelve: ['nombre', 'patas']
   </code>
   </pre>
            <p>Lo que estamos haciendo es asignarle a "caniche" las propiedades directas del constructor
                "Perro",posteriormente con un ciclo for..in y una sentencia if le asignamos a arrayDog las propiedades
                copiadas del nuevo objeto caniche.</p>
            <h2>Reducir código duplicado con la propiedad "prototype"</h2>
            <p>La propiedad "prototype" encierra y reutiliza el código para crear objetos,siendo muy útil para evitar
                las variables duplicadas dentro de cada instancia:</p>
            <pre>
    <code>
    function Perro(nombre) {
    this.nombre = nombre;
    }
    let labrador = new Perro("Mr.Dog");
    Perro.prototype.patas = 4;
    </code>
    </pre>
            <p>Aquí le asignamos a "Perro prototype" la propiedad "patas" con su valor,esto hara que todas las
                instancias de "Perro" tengan esta clave-valor en común.</p>
            <h2>Iterar en todas las propiedades,seleccionarlas individualmente y agrgarlas en arrays</h2>
            <p>En este caso queremos iterar en todas las propiedades de un constructor,para posteriormente asignar las
                propiedades directas a un array,y las propiedades prototipo a otro array:</p>
            <pre>
    <code>
    function Perro(nombre) {
    this.nombre = nombre;
    }
    Perro.prototype.patas = 4;
    let labrador = new Perro("Mr.Dog");
    let propiedadesDirectas = [];
    let propiedadesPrototipos = [];
    for(let propiedades in labrador) {
    if(labrador.hasOwnProperty(propiedades)) {
    propiedadesDirectas.push(propiedades);
    } else {
    propiedadesPrototipos.push(propiedades);
    }
    }
    console.log(propiedadesDirectas);
    console.log(propiedadesPrototipos);
    </code>
    </pre>
            <h2>Propiedad "constructor"</h2>
            <p>Este tipo de propiedades se úbica en todas las instancias creadas.Su función es verificar la propiedad
                para averiguar qué tipo de objeto es,e.j:</p>
            <pre>
    <code>
    function Perro(nombre) {
    this.nombre = nombre;
    }
    function verificarObjeto(elemento) {
    if(elemento.constructor !== Perro) {
    return false;
    }
    return true;
    }
    let caniche = new Perro('Limon');
    console.log(verificarObjeto(caniche));
    </code>
    </pre>
            <p>Debido a que la propiedad "constructor" se puede sobreescribir,normalmente,es más recomendable usar el
                método "instanceof" para verificar el tipo de un objeto.</p>
            <h2>Establecer un prototype a un objeto</h2>
            <p>Una manera más eficiente de usar los prototype es establecerlos a un objeto nuevo que ya tenga las
                propiedades que queremos:</p>
            <pre>
    <code>
    function Perro(nombre) {
    this.nombre = nombre;
    }
    Perro.prototype = {
    patas: 4,
    propietario() {
    console.log("El dueño del perro es John.");
    },
    descripcion() {
    console.log("Caniche blanco de 25kg y 40cm de alto.");
    }
    };
    let caniche = new Perro('Blanquito');
    caniche.propietario();
    console.log(caniche.patas);
    caniche.descripcion();
    </code>
    </pre>
            <h2>Establecer la propiedad "constructor" al asignar un prototipo a un nuevo objeto</h2>
            <p>Al establecer un prototipo a un objeto nuevo sucede un efecto secundario,se sobrescribe la porpiedad
                "constructor",esto se soluciona definiendo la propiedad "constructor" siempre que se establesca un
                prototipo a un objeto nuevo:</p>
            <pre>
    <code>
    Perro.prototype = {
    constructor: Perro,
    patas: 4,
    propietario() {
    console.log("El dueño del perro es John.");
    },
    descripcion() {
    console.log("Caniche blanco de 25kg y 40cm de alto.");
    }
    };
    </code>
    </pre>
            <h2>Comprender el origen del prototipo de un objeto</h2>
            <p>Es importante comprender que los objetos nuevos eredan el prototipo de la función constructor original de
                ese objeto,esto se puede comprobar con el método "isPrototypeOf()" que devolvera true o false:</p>
            <pre>
    <code>
    Perro.prototype.isPrototypeOf(caniche);
    </code>
    </pre>
            <h2>Entender a prototype</h2>
            <p>Casi todos los objetos en J.S tienen un prototipo,siendo estos mismos un objeto,por lo tanto, los
                prototype pueden tener su propio prototipo.En J.S ya viene establecido por default el Object.prototype()
                del cual todos los objetos heredan sus propiedades,es decir,Object es el supertype todos los objetos en
                J.S,esto lo podemos comprobar con "isPrototypeOf()":</p>
            <pre>
    <code>
    function Perro(nombre) {
    this.nombre = nombre;
    };
    Perro.prototype = {
    constructor: Perro,
    patas: 4,
    propietario() {},
    descripcion() {}
    };
    let caniche = new Perro('Blanquito');
    Object.prototype.isPrototypeOf(Perro.prototype);
    Perro.prototype.isPrototypeOf(caniche);
    Object.prototype.isPrototypeOf(Perro);
    //Los tres devuelven true
    </code>
    </pre>
            <h2>Seguir el principio de DRY(Don't Repeat Yourself)</h2>
            <p>El principio DRY consiste en evitar repetir código,debido a que se considera un problema porque: si se
                realiza cualquier tipo de cambio requiere corregir el código en múltiples lugares,significando más
                trabajo y mayor margen para errores:</p>
            <pre>
    <code>
    function Lagarto() {};
    Lagarto.prototype = {
    constructor: Lagarto,
    dialogo() {
    console.log("He say hello.");
    }
    };
    function Gato() {};
    Gato.prototype = {
    constructor: Gato,
    dialogo() {
    console.log("He say hello.");
    }
    };
    </code>
    </pre>
            <p>Aquí se repite el método "dialogo",para cumplir con el principio de DRY podemos crear un supertype que
                incluya este método y así eliminarlo de los constructores "Lagarto" y "Gato":</p>
            <pre>
    <code>
    function Animales() {};
    Animales.prototype = {
    constructor: Animales,
    dialogo() {
    console.log("He say hello.");
    }
    };
    </code>
    </pre>
        </div>
    </main>
    <footer>
        <h3 id="titulo-footer">Contactos:</h3>
        <div class="contactos">
            <p class="texto-final">Instragram: Fraaan.g_m</p>
            <p class="texto-final">Gmail: fgmanuello1@gmail.com</p>
            <p class="texto-final">GitHub: Francisco-G-M</p>
        </div>
    </footer>
</body>

</html>