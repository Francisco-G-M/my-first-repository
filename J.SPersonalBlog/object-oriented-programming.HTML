<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="stylesheet" href="style.CSS">
    <link rel="icon" href="JSroseLogo - copia.ico">
    <title>J.SPersonalBlog</title>
</head>

<body>
    <header>
        <h1 class="titulo">Programación orientada a objetos</h1>
        <nav>
            <a href="basic-javascript.HTML" class="enlace-barra-nav">volver al principio</a>
            <a href="ECMAScript-6.HTML" class="enlace-barra-nav">ES6</a>
            <a href="regular-Expresions.HTML" class="enlace-barra-nav">Expresiones regulares</a>
            <a href="debug.HTML" class="enlace-barra-nav">Depuración</a>
            <a href="basic-data-structure.HTML" class="enlace-barra-nav">Estructura de datos básica</a>
            <a href="basic-algorithm-programming.HTML" class="enlace-barra-nav">Programación de algoritmos
                básicos</a>
        </nav>
    </header>
    <main>
        <h1>¿Qué es la progrmación orientada a objetos?</h1>
        <div class="principio">
            <img src="OOP1.jpeg" alt="object-oriented-programming">
            <p class="definicion">La OOP (progrmación orientada a objetos) es un modelo de programación en el cual se
                utilizan los objetos
                y
                las clases para organizar el código,buscando que este sea reutilizable,organizado y sencillo de
                mantener.Este modelo sigue el principio de desarrollo de sofware DRY (Don't Repeat Yourself),que como
                dice su nombre consiste en no duplicar el código.</p>
        </div>

        <div id="object-oriented-programming">
            <h2>Definir una función "constructor"</h2>
            <p>Este tipo de funciones crean nuevos objetos que definen propiedades y comportamientos para el nuevo
                objeto:</p>
            <pre>
    <code>
    function Character() {
    this.name = "Scoby-Duu";
    this.color = "Brown";
    }            
    </code>
    </pre>
            <p>Los constructores siguen las siguientes convenciones:</p>
            <ul>
                <li>-Se definen con un nombre en mayúscula para distinguirlos de otras funciones que no sean
                    constructores.</li>
                <li>-Utilizan la clave "this" para establecer propiedades del objeto que se crea.Dentro de esta función
                    "this" se refiere al nuevo objeto.</li>
                <li>-Los constructores definen propiedades y comportamientos,a diferencia de las funciones que devuelven
                    un valor.</li>
            </ul>
            <p>Si queremos asignar el constructor a una variable:</p>
            <pre>
    <code>
    let otherCharacter = new Character();
    </code>
    </pre>
            <p>El operador "new" se utiliza para llamar a un constructor,le índica a J.S que cree una nueva instancia de
                Character llamada otherCharacter,si no usaramos "new" dentro del constructor "this" no haría referencia
                al nuevo objeto.Ahora otherCharacter tiene todas las propiedades del constructor,pudiendo nosotros
                acceder y modificar este nuevo objeto:</p>
            <pre>
    <code>
    otherCharacter.name = "BigBoy";
    </code>
    </pre>
            <h2>constructor con argumentos</h2>
            <p>La función de los parametros en los constructores es volverlos más flexibles,pudiendo definir las
                propiedades de cada nuevo objeto en el momento que se crea:</p>
            <pre>
   <code>
   function Dog(name, color) {
   this.name = name;
   this.color = color;
   this.legs = 4;
   }
   let goldenTerrier = new Dog("BigBoy", "Golden");
   </code>
   </pre>
            <h2>Verificar el constructor de un objeto con "instanceof"</h2>
            <p>La función de "instanceof" es verificar la instancia de un objeto de un determinado
                constructor,básicamente compara un objeto con un constructor,devolviendo true o false si el objeto fue
                creado/o no con ese constructor:</p>
            <pre>
   <code>
   function Propiedad(numberOfHouse) {
   this.numberOfHouse = numberOfHouse;
   }
   let miPropiedad = new Propiedad(17);
   miPropiedad instanceof Propiedad;
   //Esto devuelve true,támbien podemos llamarlo con un console.log():
   console.log(miPropiedad instanceof Propiedad);
   //támbien devuelve true
   </code>
   </pre>
            <h2>Propiedades directas</h2>
            <p>Denominados propiedades directas a todo aquello definido en la instancia de un objeto,e.j:</p>
            <pre>
   <code>
   function Perro(nombre) {
   this.nombre = nombre;
   this.patas = 4;
   } 
   let caniche = new Perro("Limon");
   let arrayDog = [];
   for(let agregar in caniche) {
   if(agregar in caniche) {
   arrayDog.push(agregar);
   }
   }
   console.log(arrayDog);
   //Aquí nos devuelve: ['nombre', 'patas']
   </code>
   </pre>
            <p>Lo que estamos haciendo es asignarle a "caniche" las propiedades directas del constructor
                "Perro",posteriormente con un ciclo for..in y una sentencia if le asignamos a arrayDog las propiedades
                copiadas del nuevo objeto caniche.</p>
            <h2>Reducir código duplicado con la propiedad "prototype"</h2>
            <p>La propiedad "prototype" encierra y reutiliza el código para crear objetos,siendo muy útil para evitar
                las variables duplicadas dentro de cada instancia:</p>
            <pre>
    <code>
    function Perro(nombre) {
    this.nombre = nombre;
    }
    let labrador = new Perro("Mr.Dog");
    Perro.prototype.patas = 4;
    </code>
    </pre>
            <p>Aquí le asignamos a "Perro prototype" la propiedad "patas" con su valor,esto hara que todas las
                instancias de "Perro" tengan esta clave-valor en común.</p>
            <h2>Iterar en todas las propiedades,seleccionarlas individualmente y agrgarlas en arrays</h2>
            <p>En este caso queremos iterar en todas las propiedades de un constructor,para posteriormente asignar las
                propiedades directas a un array,y las propiedades prototipo a otro array:</p>
            <pre>
    <code>
    function Perro(nombre) {
    this.nombre = nombre;
    }
    Perro.prototype.patas = 4;
    let labrador = new Perro("Mr.Dog");
    let propiedadesDirectas = [];
    let propiedadesPrototipos = [];
    for(let propiedades in labrador) {
    if(labrador.hasOwnProperty(propiedades)) {
    propiedadesDirectas.push(propiedades);
    } else {
    propiedadesPrototipos.push(propiedades);
    }
    }
    console.log(propiedadesDirectas);
    console.log(propiedadesPrototipos);
    </code>
    </pre>
            <h2>Propiedad "constructor"</h2>
            <p>Este tipo de propiedades se úbica en todas las instancias creadas.Su función es verificar la propiedad
                para averiguar qué tipo de objeto es,e.j:</p>
            <pre>
    <code>
    function Perro(nombre) {
    this.nombre = nombre;
    }
    function verificarObjeto(elemento) {
    if(elemento.constructor !== Perro) {
    return false;
    }
    return true;
    }
    let caniche = new Perro('Limon');
    console.log(verificarObjeto(caniche));
    </code>
    </pre>
            <p>Debido a que la propiedad "constructor" se puede sobrescribir,normalmente,es más recomendable usar el
                método "instanceof" para verificar el tipo de un objeto.</p>
            <h2>Establecer un prototype a un objeto</h2>
            <p>Una manera más eficiente de usar los prototype es establecerlos a un objeto nuevo que ya tenga las
                propiedades que queremos:</p>
            <pre>
    <code>
    function Perro(nombre) {
    this.nombre = nombre;
    }
    Perro.prototype = {
    patas: 4,
    propietario() {
    console.log("El dueño del perro es John.");
    },
    descripcion() {
    console.log("Caniche blanco de 25kg y 40cm de alto.");
    }
    };
    let caniche = new Perro('Blanquito');
    caniche.propietario();
    console.log(caniche.patas);
    caniche.descripcion();
    </code>
    </pre>
            <h2>Establecer la propiedad "constructor" al asignar un prototipo a un nuevo objeto</h2>
            <p>Al establecer un prototipo a un objeto nuevo sucede un efecto secundario,se sobrescribe la porpiedad
                "constructor",esto se soluciona definiendo la propiedad "constructor" siempre que se establesca un
                prototipo a un objeto nuevo:</p>
            <pre>
    <code>
    Perro.prototype = {
    constructor: Perro,
    patas: 4,
    propietario() {
    console.log("El dueño del perro es John.");
    },
    descripcion() {
    console.log("Caniche blanco de 25kg y 40cm de alto.");
    }
    };
    </code>
    </pre>
            <h2>Comprender el origen del prototipo de un objeto</h2>
            <p>Es importante comprender que los objetos nuevos eredan el prototipo de la función constructor original de
                ese objeto,esto se puede comprobar con el método "isPrototypeOf()" que devolvera true o false:</p>
            <pre>
    <code>
    Perro.prototype.isPrototypeOf(caniche);
    </code>
    </pre>
            <h2>Entender a prototype</h2>
            <p>Casi todos los objetos en J.S tienen un prototipo,siendo estos mismos un objeto,por lo tanto, los
                prototype pueden tener su propio prototipo.En J.S ya viene establecido por default el Object.prototype()
                del cual todos los objetos heredan sus propiedades,es decir,Object es el supertype todos los objetos en
                J.S,esto lo podemos comprobar con "isPrototypeOf()":</p>
            <pre>
    <code>
    function Perro(nombre) {
    this.nombre = nombre;
    };
    Perro.prototype = {
    constructor: Perro,
    patas: 4,
    propietario() {},
    descripcion() {}
    };
    let caniche = new Perro('Blanquito');
    Object.prototype.isPrototypeOf(Perro.prototype);
    Perro.prototype.isPrototypeOf(caniche);
    Object.prototype.isPrototypeOf(Perro);
    //Los tres devuelven true
    </code>
    </pre>
            <h2>Seguir el principio de DRY(Don't Repeat Yourself)</h2>
            <p>El principio DRY consiste en evitar repetir código,debido a que se considera un problema porque: si se
                realiza cualquier tipo de cambio requiere corregir el código en múltiples lugares,significando más
                trabajo y mayor margen para errores:</p>
            <pre>
    <code>
    function Lagarto() {};
    Lagarto.prototype = {
    constructor: Lagarto,
    dialogo() {
    console.log("He say hello.");
    }
    };
    function Gato() {};
    Gato.prototype = {
    constructor: Gato,
    dialogo() {
    console.log("He say hello.");
    }
    };
    </code>
    </pre>
            <p>Aquí se repite el método "dialogo",para cumplir con el principio de DRY podemos crear un supertype que
                incluya este método y así eliminarlo de los constructores "Lagarto" y "Gato":</p>
            <pre>
    <code>
    function Animales() {};
    Animales.prototype = {
    constructor: Animales,
    dialogo() {
    console.log("He say hello.");
    }
    };
    </code>
    </pre>
            <h2>Usar "Object.create()" para heredar comportamientos de un supertrype</h2>
            <p>La función de este método es crear un nuevo objeto y establecer lo que va dentro del parentesis como el
                prototype del nuevo objeto:</p>
            <pre>
    <code>
    let pajaro = Object.create(Animales.prototype);
    let oso = Object.create(Animales.prototype);
    </code>
    </pre>
            <h2>Establecer el subtype prototype como instancia del supertype</h2>
            <p>También podemos usar el método "Object.create()" para hacer que los subtytpe hereden las propiedades del
                supertype:</p>
            <pre>
    <code>
    function Animales() {};
    Animales.prototype = {
    constructor: Animales,
    descripcion() {
    console.log("He say hello.");
    }
    };
    function Perro() {};
    Perro.prototype = Object.create(Animales.prototype);
    let labrador = new Perro();
    labrador.descripcion();
    </code>
    </pre>
            <h2>Restablecer un "constructor" heredado</h2>
            <p>Al heredar un nuevo objeto(subtype) el prototype de otro objeto(supertype),también adquiere el
                constructor del supertype,esto se puede solucionar estableciendo manualmente el constructor correcto a
                cada nuevo objeto:</p>
            <pre>
    <code>
    function Animales() {};
    function Gatos() {};
    function Aves() {};
    Gatos.prototype = Object.create(Animales.prototype);
    Aves.prototype = Object.create(Animales.prototype);
    let ocelote = new Gatos();
    let gaviota = new Aves();
    //Aquí ambos let tienen el constructor "Animales"
    Gatos.prototype.constructor = Gatos;
    Aves.prototype.constructor = Aves;
    //Ahora los dos let tienen el constructor correcto
    </code>
    </pre>
            <h2>Agregar métodos a un objeto nuevo tras asignarle una herencia</h2>
            <p>Cuando un subtype hereda un prototype de un supertype no solo optiene los métodos del supertype,sino que
                también mantiene sus propias propiedades/mátodos:</p>
            <pre>
    <code>
    function Animales() {};
    Animales.prototype.comer = function() {
    console.log("Munch munch");
    };
    function Perro() {};
    Perro.prototype = Object.create(Animales.prototype);
    Perro.prototype.constructor = Perro;
    Perro.prototype.ladrido = function() {
    console.log("Woof woof");
    }
    </code>
    </pre>
            <h2>Como sobrescribir métodos heredados</h2>
            <p>En caso de que quisieramos sobrescribir una propiedad/método heredado,tenemos que llamar al prototype de
                la instancia junto con el nombre del método a sobrescribir:</p>
            <pre>
    <code>
    function Aves() {};
    Aves.prototype.characteristic = function() {
    return "Las Aves se distinguen por poder volar";
    };
    Aves.prototype.size = "Small";
    function Gaviota() {};
    Gaviota.prototype = Object.create(Aves.prototype);
    Gaviota.prototype.constructor = Gaviota;
    Gaviota.prototype.size = "Medium";
    Gaviota.prototype.characteristic = function() {
    return "Las Gaviotas se caracterizan por estar normalmente en las costas.";
    };
    //Como se puede observar,aquí sobrescribimos la propiedad "size" y el método "characteristic" en la instancia "Gaviota"
    let gaviota = new Gaviota();
    console.log(gaviota.size);
    console.log(gaviota.characteristic());
    </code>
    </pre>
            <h2>Usar un "mixin" para definir un comportanmiento común entre objetos no relacionados</h2>
            <p>Como ya vimos,las herencias se realizan entre objetos relacionados,pero en el caso contrario no se
                recomienda usar una herencia,para ello podemos usar un "Mixin",el cual permite que otros objetos puedan
                utilizar una colección de funciones:</p>
            <pre>
    <code>
    let disneyCharacter = {
    name: "Donal",
    animal: "Duck"
    };
    let plane = {
    name: "Avioneitor",
    typePlane: "Small Plane"
    };
    let abilityMixin = function(obj) {
    obj.fly = function() {
    console.log(this.name + " It's fly,HE CAN FLY");
    }
    };
    abilityMixin(disneyCharacter);
    abilityMixin(plane);
    disneyCharacter.fly();
    plane.fly();
    </code>
    </pre>
            <h2>Prevenir la modificación de las propiedades de un objeto mediante los "closure"</h2>
            <p>La gran desventaja de declarar propiedades públicas(como plane.name del tema anterior) es que se pueden
                acceder y cambiar en cualquier parte del código,lo cual nos puede generar muchos problemas en un
                futuro.Para evitar esto podemos convertir la propiedad pública en privada,esto se logra creando una
                variable dentro de la función constructora(lo cual va a cambiar su alcance global a uno local).Siendo
                así que,la variable solo se puede acceder y cambiar por métodos que esten dentro de la misma función
                constructora:</p>
            <pre>
    <code>
    function User1() {
    let id = 72899;
    this.accessibilityId = function() {
    return id;
    }
    };
    let bob = new User1();
    console.log(bob.accessibilityId());
    </code>
    </pre>
            <p>En este caso,accessibilityId es el método privado,ya que tiene acceso a la variable privada "id",esto es
                posible porque ambos estan declarados en el mismo contexto.Esto es conocido como un "closure",que en J.S
                básicamente consiste en que una función siempre tiene acceso al contexto en el que se creó.</p>
            <h2>Funciones invocadas inmediatamente(IIFE)</h2>
            <p>Las Inmediaty Invoked Function Expression (IIFE) son un patrón común en J.S que consiste en la ejecución
                de una función apenas declarada.Estos patrones estan formados por una función anónima encerrada entre
                paréntesis juntó con otro par de paréntesis al final(esta parte sirve para llamar inmediatamente a la
                función):</p>
            <pre>
    <code>
    (function() {
    console.log("I am a anonymous function");
    })();
    </code>
    </pre>
            <h2>Crear un módulo usando una IIFE</h2>
            <p>Las IIFE a menudo se utilizan para agrupar propiedades/métodos en un único objeto/módulo:</p>
            <pre>
    <code>
    let groupMixin = (function() {
    return {
    user1: function(obj) {
    obj.id = function() {
    console.log("El ID del user1 es: " + 72899);
    };
    },
    user2: function(obj) {
    obj.greeting = function() {
    console.log("Hi people.");
    };
    }
    }
    })();
    let bob = {};
    groupMixin.user1(bob);
    groupMixin.user2(bob);
    bob.id();
    bob.greeting();
    </code>
    </pre>
            <p>Aquí invocamos una IIFE que nos devuelve el objeto "groupMixin",el cual tiene de propiedades todos los
                comportamientos de los Mixin.La gran ventaja de crear modulos con IIFE es que podemos empaquetar en un
                único objeto los comportamientos de los Mixin,que podra ser usado en cualquier parte del código.</p>
        </div>
    </main>
    <footer>
        <h3 id="titulo-footer">Contactos:</h3>
        <div class="contactos">
            <a href="https://www.instagram.com/fraaan.g_m/" target="_blank" class="social-media">Instagram: fraaan.g_m</a>
            <p class="texto-final">Gmail: fgmanuello1@gmail.com</p>
            <p class="texto-final">GitHub: Francisco-G-M</p>
        </div>
    </footer>
</body>

</html>