<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="stylesheet" href="style.CSS">
    <link rel="icon" href="JSlogoIA.ico">
    <title>J.SPersonalBlog</title>
</head>

<body>
    <header>
        <nav class="sections">
            <a href="principal-page.HTML" class="enlace-barra-nav">Volver al principio</a>
            <a href="basic-javascript.HTML" class="enlace-barra-nav">Basic.JS</a>
            <a href="ECMAScript-6.HTML" class="enlace-barra-nav">ES6</a>
            <a href="regular-Expresions.HTML" class="enlace-barra-nav">Regular.E</a>
            <a href="basic-data-structure.HTML" class="enlace-barra-nav">Basic.D.S</a>
            <a href="basic-algorithm-programming.HTML" class="enlace-barra-nav">Basic.A.P</a>
            <a href="object-oriented-programming.HTML" class="enlace-barra-nav">OOP</a>
            <a href="functional-programming.HTML"  class="enlace-barra-nav">Functional.P</a>
            <a href="method's.HTML" class="enlace-barra-nav">Method's</a>
        </nav>
        <h1 class="titulo">Depuración</h1>
    </header>
    <main>
        <h2 class="inicialH2">¿Qué es la Depuración?</h2>
        <div class="presentacion-tema">
            <img src="debugging.jpeg" alt="debugging-logo">
            <p>La Depuración es el proceso de buscar y solucionar los errores/fallos en el código.Su
                objetivo es garantizar el correcto funcionamiento y ejecución del código.Estos
                mismos errores aparecen
                en tres formas diferentes:</p>
        </div>
        <div id="debugging">
            <h3>Errores de sintaxis</h3>
            <p>Son errores de ortografía que impiden la correcta ejecución de tu programa,probocando que deje de
                funcionar a la mitad de la ejecución o
                que no se ejecute en lo absoluto.</p>
            <h3>Errores en el tiempo de ejecución</h3>
            <p>Suceden cuándo se produce un comportamiento inesperado en el código.Normalmente por condiciones que el
                programador no que podrían llegar a ocurrir.</p>
            <h3>Errores lógicos</h3>
            <p>Estos tipos de errores se producen cuándo tu código no hace lo que querias.Estos casos llega a pasar que
                la sintaxis es correcta pero el resultado es diferente a lo deseado.</p>
            <h2>Usar la consola de J.S para comprobar el valor de una variable</h2>
            <p>En J.S el método "console.log()" "imprime" la salida del contenido entre parentesis en la
                consola,colocarlos en puntos estratéicos del código permite ver los valores intermedios de las
                variables,tener puntos de control para ver el estado de los cálculos en el código ayuda a determinar
                dónde esta el problema:</p>
            <pre>
    <code>
    let x = 10;
    let y = 10;
    x++;
    console.log(x);//punto de control
    let sum = x + y;
    console.log(sum);
    </code>
    </pre>
            <h2>Tipos de datos con console</h2>
            <p>Fuera de "console.log()" existen otros tipos de metodos para console,los cuales son:</p>
            <h3>console.warn()</h3>
            <p>Su función es imprimir texto en la consola como una advertencia.</p>
            <h3>console.error()</h3>
            <p>Su función es mostrar un mensaje de error en la consola.</p>
            <h3>console.info()</h3>
            <p>Muestra en la consola un mensaje informativo.</p>
            <h3>console.log()</h3>
            <p>Imprime texto en la consola como un mensaje de registro.</p>
            <pre>
    <code>
    console.warn('Esto es una advertencia');
    console.error('Esto es un error');
    console.info('Esto es un mensaje informativo');
    console.log('Esto es un mensaje de registro o punto de control del código');
    </code>
    </pre>
            <h2>Usar typeof para comprobar el tipo de una variable</h2>
            <p>La función de typeof es comprobar la estructura de datos o el tipo de una variable.Siendo útil para
                depurar si trabajamos con múltiples tipos de datos:</p>
            <pre>
    <code>
    let string1 = 10;
    let string2 = "hola";
    let string3 = {};
    let string4 = [];
    let string5 = '';
    console.log(typeof string1);
    console.log(typeof string2);
    console.log(typeof string3);
    console.log(typeof string4);
    console.log(typeof string5);
    </code>
    </pre>
            <h2>Detectar nombres de funciones y variables mal escritos</h2>
            <p>Uno de los problemas que podemos tener en nuestro código son los errores de sintaxis que suelen suceder
                al escribir muy rápido y provoca errores ortográficos.Los caracteres transpuestos,faltantes o mal
                escritos en una variable o nombre de función provocan que el navegador busque un objeto inexistente y
                que figure un error de referencia.Esto se corrije simplemente con revisar el código hasta encontrar lo
                que este mal escrito.</p>
            <h2>Capture paréntesis,corchetes,llaves y comillas no cerrados</h2>
            <p>Otro tipo de error común es no escribir el cierre de parentesis,corchetes,llaves y comillas.Actualmente
                la mayoría de los editores de código modernos generan el cierre del ítem automáticamente.</p>
            <h2>Capture el uso mixto de comillas simples y dobles</h2>
            <p>En caso de que quisieramos usar dos tipos de comillas en una cadena,tenemos dos opciones: usar un tipo de
                comilla para encerrar la oración,y dentro de ella encerrar una parte específica:</p>
            <pre>
    <code>
    let stringA = "Escapar 'comillas simples'";
    console.log(stringA);
    //Oh también escapar las comillas dentro de una cadena usando "\":
    let stringB = 'Escapar \'esto\'';
    console.log(stringB);
    </code>
    </pre>
            <h2>Captar el uso del operador de asignación en lugar del operador de igualdad</h2>
            <p>Los programas ramificados(aquellos que hacen algo si se cumplen ciertas ciertas condiciones/parametro) se
                basan en declaraciones(if,else,else if),las cuales a veces toma la forma de probar si un resultado es
                igual a un valor,usando el operador "=".Esto conduce a un flujo de control inesperado en su
                programa,esto es así porque: en J.S el operador "=" asigna un valor a un nombre de variable,en
                cambio,los operadores "==" "===" verifican la igualdad:</p>
            <pre>
    <code>
    let x = 1;
    let y = 10;
    let result;
    if(x === y) {
    result = "igual";
    } else {
    result = "diferente";
    }
    console.log(result);
    //Aquí devuelve "diferente",si usaramos "==" en el parametro/condición devolviera lo mismo.
    </code>
    </pre>
            <h2>Detectar parentesis faltantes tras una llamada a la función</h2>
            <p>En algunos casos,cuando una función/método no tiene argumento,es común olvidar incluir los paréntesis
                vacíos al llamarlo.En estos casos podemos detectarlo asignandole el resultado de una llamada a una
                función a una variable,ya que veremos que uno está configurado como una referencia de función,en lugar
                del valor que devuelve la función:</p>
            <pre>
    <code>
    function string() {
    let a = 10;
    let b = 6;
    let c = 4;
    return a + b + c;
    }
    let final = string;
    console.log(string);
    //Aquí nos devuelve: [function: string]
    let other = string();
    console.log(other);
    //Aquí si nos devuelve el valor de la función,en este caso,la suma de las variables a + b + c
    </code>
    </pre>
            <h2>Captar argumentos en el orden incorrecto al llamar a una función</h2>
            <p>Otro tipo de error en las funciones es cuando los argumentos se proporcionan en el orden incorrecto,esto
                produce un error de tiempo de ejeccución,esto se soluciona dando todos los argumentos necesarios en el
                orden correcto:</p>
            <pre>
    <code>
    let elevarNumeroConExponente(n, e) {
    return Math.pow(n, e);
    }
    let numero = 4;
    let exponente = 2;
    let resultado = elevarNumeroConExponente(exponente, numero);//Esto sería la verción mal escrita
    let final = elevarNumeroConExponente(numero, exponente);//Esta sería la verción correcta
    //Dato extra: Math.pow() devuelve la base elevada al exponente,e.j:
    let a = 4;
    let b = 2;
    let theFinal = Math.pow(a, b);
    console.log(theFinal);//Esto dvuleve 16
    </code>
    </pre>
            <h2>Errores de captura por uno al usar la indexación</h2>
            <p>Los errores de uno por uno(también conocidos OBOE) nace cuando se intenta acceder a un índice específico
                de una cadena/matríz o si recorremos sus índices.En J.S la indexación inicia en 0(y no en 1),esto
                significa que el último índice es uno menos que la longitud de la cadena/matríz.Si se comete este error
                se produce un error de referencia de "índice fuera de rango" o se imprime en la consola "undefined":</p>
            <pre>
    <code>
    function contarHastaTres() {
    let conteo = "123";
    let contar = conteo.length;
    for(let i = 0; i &lt contar; i++) {
    console.log(conteo[i]);
    }    
    }
    </code>
    </pre>
            <h2>Tener precaución al reinicializar variables dentro de un bucle</h2>
            <p>Un posible problema al guardar información,incrementar contadores o restablecer variables dentro de un
                bucle,surge cuando las variables deben reinicializarce o no(y viceversa),esto es peligroso debido a que
                si erróneamente se restablece la variable que se usa para un bucle infinito:</p>
            <pre>
    <code>
    function arregloDeCeros(x, y) {
    let nuevoArreglo = [];
    for(let a = 0; a &lt x; a++) {
    let hileras = [];
    for(let b = 0; b &lt y; b++) {
    hileras.push(0);
    }
    nuevoArreglo.push(hileras);
    }
    return nuevoArreglo;
    }
    let resultado = arregloDeCeros(3, 2);
    console.log(resultado); 
    </code>
    </pre>
            <h2>Evitar bucles infinitos con una condición terminal válida</h2>
            <p>Producir un bucle infinito es un tipo de error que puede provocar que los navegadores se
                bloqueen/congelen y provoquen un caos general en la ejecución del programa.Estos bucles pueden
                originarce por incrementar o disminuir una variable de contador en la dirección incorrecta desde la
                condición terminal.También lo produce el reestablecer erroneamente un contador o una variable de índice
                dentro del código del bucle(en vez de incrementarlo o disminuirlo):</p>
            <pre>
    <code>
    function infiniteLoop() {
    for(let n = 1; n != 4; n += 2) {
    console.log("Whait!,this is a infinite loop");
    }
    }
    /Al ser n!= 4 nunca sera false(es decir,nunca se termina el bucle) n se incrementa de 2 en 2 cada pasada y se pasa de 4,porque n es igual a 1
    (es decir,porque n es impar al comienzo del bucle).Esto se soluciona corrigiendo la condición terminal,haciendo que el bucle solo se ejecute si n
    es menor/igual a 4*/
    for(let n = 1; n &lt 4; n += 2)
    </code>
    </pre>
        </div>
    </main>
    <footer>
        <h3 id="titulo-footer">Contactos:</h3>
        <div class="contactos">
            <a href="https://www.instagram.com/fraaan.g_m/" target="_blank" class="social-media">Instagram:
                fraaan.g_m</a>
            <a href="mailto:fgmanuello1@gmail.com" target="_blank" class="social-media">Gmail: fgmanuello1@gmail.com</a>
            <a href="https://github.com/Francisco-G-M" target="_blank" class="social-media">GitHub: Francisco-G-M</a>
        </div>
    </footer>
</body>

</html>