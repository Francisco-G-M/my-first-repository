<!DOCTYPE html>
<html lang="Es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.CSS">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <title>J.SPersonalBlog</title>
</head>

<body>
    <header>
        <h1>ECMAScript 6</h1>
        <nav>
            <a href="basic-javascript.HTML" class="enlace-barra-nav">volver al principio</a>
        </nav>
    </header>
    <main>
        <h2>¿Qué es ES6?</h2>
        <div class="principio">
            <img src="ES6logo.jpg" alt="ES6-logo">
            <p class="definicion">ES6(ECMAScript 6) es el nuevo estándar de JavaScript,la cuál agregó nuevas
                características al
                lenguaje,estos cambios en la sintaxis nos permite escribir código de una manera más rápida y limpia.</p>
        </div>
        <div id="ES6">
            <h2>var vs let</h2>
            <p>La diferencia entre declarar una variable con var o let es que,si declaras con con var,podras declarar
                esa variable dos o más veces:</p>
            <pre>
    <code>
    var campista = "James";
    var campista = "David";
    //Pero con let solo puedes declarar una variable una única vez:
    let campista = "David";
    //Lo que si puedes hacer es reaccinar el valor.
    </code>
    </pre>
            <h2>Ámbito de var vs let</h2>
            <p>Las diferencias en el ambito de las variables declaradas con var o con let son:</p>
            <p>La variable var tiene un ámbito global,pero si esta dentro de una función sera una variable local.Pero
                con let las variables tienen el ámbito local restringido al bloque de código/expresión donde fue
                declarada/definida la variable.</p>
            <h2>Const</h2>
            <p>Es la tercera opción para declarar una variable,estas solo se pueden usar para acceder a su valor,su
                valor no se puede modificar una vez ya allá sido declarado:</p>
            <pre>
    <code>
    const MI_CONSTANTE = 35;
    /*Se escribe en mayúsculas el nombre de las const para poder distinguirlas y para que los desarrolladores sepan que no deben intentar cambiar
    el valor de esa constante.*/
    //Si la usaramos en una función:
    function calcularAreaCirculo(radio) {
    const PI = 3.14;
    if(radio < 0) {
    return undefined;
    }
    return PI*(radio**2);
    }
    console.log(calcularAreaCirculo(10));
    //Usar dos ** índica que es el operador para una potencia,el número al lado de ellos sera la potencia deseada.
    </code>
    </pre>
            <h2>Mutar arreglo declarado con const</h2>
            <p>Si bien a las variables declaradas con "const" no le puedes asignar un valor nuevo,si lo puedes cambiar:
            </p>
            <pre>
    <code>
    const MI_ARREGLO = [1, 2, 3, 4,];
    MI_ARREGLO[0] = 5;
    /*Lo que hacemos es cambiar los elementos del arreglo,básicamente podemos reaccinar el valor del arreglo,pero no el valor directo de la 
    variable declarada con "const"*/
    </code>
    </pre>
            <h2>Crear un objeto inmutable</h2>
            <p>Para lograr que un objeto sea inmutable usaremos el metodo freeze():</p>
            <pre>
    <code>
    let colores = {
    "verde": "#10e04b",
    "azul": "#1b50e0",
    "negro": "#000000",
    "blanco": "#ffffff"
    };
    object.freeze(colores);
    /*object nos permite dar funcionalidades en común a todos los objetos.Pero al usar freeze,entre () aclaramos que un objeto determinado sera
    el afectado*/
    </code>
    </pre>
            <h2>Funciones flecha</h2>
            <p>Es un tipo de función más compacta utilizada normalmente para funciones anonimas(funciones sin un nombre
                especifíco):</p>
            <pre>
    <code>
    const fecha = function() {
    return new date();
    };
    //"new date" crea un objeto con la fecha actual del sistema.
    /*Si quisieramos transformar esta función en un tipo flecha,tendríamos que eliminar la palabra clave function,la apertura y cierre de la llave,
    la sentencia return y escribimos el símbolo característico de las funciones flecha (=>):
    const fecha = () => nex date();
    /*Dato importante: las funciones flecha son muy utiles cuando queremos pasar una función como argumento a otra función,lo que hacemos es
    escribirla directamente como el argumento.
    </code>
    </pre>
            <h2>Funciones flecha con parámetros</h2>
            <p>Para definir funciones flechas que tengan uno o más parametros:</p>
            <pre>
    <code>
    //Si es de una sola línea,eliminamos las palabras function y return,la apertura y cierre de llave,y agregamos la flecha:
    const sumarTres = (x) => x + 3;
    console.log(sumarTres(4));
    //En caso de una función con dos parametros hacemos exactamente lo mismo:
    const CONCATENAR_ARREGLOS = (arr1, arr2) => arr1.concat(arr2);
    console.log(CONCATENAR_ARREGLOS([1, 2], [3, 4, 5]));
    //.concat() es un metodo que permite unir arreglos.
    //Si la función tiene más de una línea: borramos el function y la apertura de la llave:
    const SUMAR = (a, b) => {
    let num = 6;
    return a + b + num;
    };
    console.log(SUMAR(1, 1));
    </code>
    </pre>
            <h2>Valores por defecto para parámetros</h2>
            <p>Para asignar un valor por defecto a los parámetros de una función flecha tendríamos que escribir un signo
                igual y el valor por defecto:</p>
            <pre>
    <code>
    const INCREMENTAR = (num, valor = 1) => num + valor;
    //En caso de que se omita el argumento valor,se asignara el valor por defecto.
    //Este principio también se puede aplicar a las funciones normales y sus variantes,y a las anonimas.
    </code>
    </pre>
            <h2>Operador rest</h2>
            <p>Permite pasar cualquier número de argumentos a una función,y que esos argumentos se agrupen como un
                arreglo:</p>
            <pre>
    <code>
    function miFuncion(...arrgs) {
    console.log(arrgs);
    }
    miFuncion(1, 2, 3, 4); // Oh también:
    miFuncion([1, 2, 3], [4, 5, 6]); //Oh puedes usar .length() :
    console.log(arrgs.length);
    const SUMAR = (...arrgs) => {
    return arrgs.reduce((a, b) => a + b,0);
    };
    /*El metodo .reduce() nos permite reducir el array a un solo valor,sumando los elementos del arreglo y retornando
    el resultado*/
    </code>
    </pre>
            <h2>Operador spread</h2>
            <p>Su función es descomponer un arreglo en sus elementos individuales para que la función pueda recibirlos y
                asignarlos a sus parametros correspondientes:</p>
            <pre>
    <code>
    const numeros = [1, 2, 3];
    function sumar (x, y, z) {
    return x + y + z;
    }
    console.log(sumar(...numeros));
    //Usamos el mismo símbolo que .rest(),pero lo escribimos en la llamada a la función. 
    </code>
    </pre>
            <h2>Sintaxis de desestructuración</h2>
            <p>Permite asignar las propiedades de un objeto a variables:</p>
            <pre>
    <code>
    var coordenadas = {
    x: 4,
    y: 6,
    z: 12
    }
    const {x, y, z} = coordenadas;
    </code>
    </pre>
            <h2>Sintaxis de desestructuración: objetos anidados</h2>
            <p>Para acceder a los datos de un objeto anidado haríamos lo siguiente:</p>
            <pre>
    <code>
    const usuario = {
    joseph: {
    edad: 30,
    correo: "JopsephJoestar@gmail.com"
    }
    };
    const {joseph: {edad: edadDelUsuario, correo: correoDelUsuario}} = usuario;
    //Como ven,para acceder a los objetos anidados,debemos escribir otro corchete que tenga dentro el nombre de aquellos objetos.
    /*Lo que esta escrito despues de los nombres de las porpiedades que queremos acceder son los nuevos nombres que queremos asignarles a las
    propiedades (esto es completamente opcional).Si llegasemos a llamarlos,tendríamos que usar estos nuevos nombres*/
    const PRONOSTICO_LOCAL = {
    "ayer": {
    minima: "-1",
    maxima: 6
    },
    "hoy": {
    minima: 1,
    maxima: 4
    },
    "mañana" = {
    minima: 2,
    maxima: 10
    }
    };
    const {hoy: {minima, maxima}} = PRONOSTICO_LOCAL;
    console.log(minima, maxima);
    //Usamos una coma y un espacio para que en una sola línea figuren los dos datos.
    </code>
    </pre>
            <h2>Sintaxis de desestructuración: arreglos</h2>
            <p>Nos permite asignar valores a variables usando arreglos:</p>
            <pre>
    <code>
    var a;
    var b;
    var c;
    [a, b,,,c] = [1, 2, 3, 4, 5, 6];
    //Ponemos dos comas más para que la var c tome com valor a 5,es decir las dos comas son para que se salten los valores 3 y 4.
    var x = 8;
    var y = 6;
    [y, x] = [x, y];
    //Escribimos esto porque: queremos que x y b reciban el valor del otro.
    console.log("x: " + x);
    console.log("y: " + y);
    </code>
    </pre>
            <h2>Sintaxis de desestructuración con el operador rest</h2>
            <p>Permite reaccinar un arreglo en varias variables:</p>
            <pre>
    <code>
    var a;
    var b;
    var arr;
    [a, b, ...arr] = [1, 2, 3, 4, 5, 6, 7];
    console.log(a);
    console.log(b);
    console.log(arr);
    //En caso de que quisieramos remover los tres primeros elementos de un arreglo:
    const arregloInicial = [1, 2, 3, 4, 5, 6, 7, 8];
    function removerTresPrimerosElementos(arreglo) {
    const [,,, ...nuevoArreglo] = arreglo;
    return nuevoArreglo;
    }
    const arregloFinal = removerTresPrimerosElementos(arregloInicial);
    console.log(arregloFinal);
    </code>
    </pre>
            <h2>Sintaxis de desestructuración: pasar objeto como argumento</h2>
            <p>Para pasar un objeto como argumento primero identificamos que propiedades vamos a necesitar en la función
                y escribirlas entrre llaves en el primer parametro,asignandoce esos valores a variables,que podemos
                trabajar en la función:</p>
            <pre>
    <code>
    var nuevoPerfilCliente = {
    nombre: "Jon Doe",
    edad: 24,
    nacionalidad: "Española",
    ubicacion: "España"
    };
    const actualizarPerfil = ({nombre, edad, nacionalidad, ubicacion}) => {
    console.log(nombre);
    console.log(edad);
    console.log(nacionalidad);
    console.log(ubicacion);
    };
    actualizarPerfil(nuevoPerfilCliente);
    //Otro ejemplo:
    const estadisticas = {
    max: 56.78,
    min: -0.75
    };
    const mitad = ({max, min}) => (max + min) /2.0;
    console.log(mitad(estadisticas));
    </code>
    </pre>
            <h2>Plantillas literales</h2>
            <p>Es un tipo de cadena de caracteres que permite crear cadenas con varias líneas y reemplazar los valores
                de las variables que querramos,algunas de sus características son:</p>
            <p>
                1-Utiliza el acento invertido `` en vez de comillas.<br>
                2-Puede usar tanto comillas simples como dobles.<br>
                3-Las líneas de código se preservan.<br>
                4-En caso de reemplazar una variable se escribe: ${variable}<br>
                5-Puede escribir expresiones dentro de ${}
            </p>
            <pre>
    <code>
    var nombre = "Diego";
    var edad = 8;
    console.log(`Mi nombre es ${nombre} y tengo ${edad} años.`);
    var persona = {
    nombre: "Mario Fernandes",
    edad 40
    };
    const SALUDO = `¡Hola! Mi nombre es ${persona.nombre} y tengo ${persona.edad} años.`;
    console.log(SALUDO);
    var myArray = [1, 2, 3, 4];
    console.log(`El arreglo es ${JSON.stringify(myArray)}`);
    </code>
    </pre>
            <h2>Crear objetos de forma concisa</h2>
            <p>Lo que haremos sera utilizar una funcion flecha,seguido de su simbolo característico escribimos un
                parentesis con un par de llaves que dentro tendran los mismos parametros que tiene el parentesis del
                principio:</p>
            <pre>
    <code>
    const JOESTAR = (nombre, edad, stand) => ({nombre, edad, stand});
    console.log(JOESTAR("Jotaro Kujo", 17, "Star Platinum"));
    </code>
    </pre>
            <h2>Métodos</h2>
            <p>Se denomina "método" a la propiedad que tenga de valor una función:</p>
            <pre>
    <code>
    const PERSONAJE_FICTICIO = {
    nombre: "Naruto Uzumaki",
    objetivo: "Hokage",
    presentacion() {
    return `¡Hola! mi nombre es ${this.nombre} y sere el próximo ${this.objetivo}.`;
    }
    };
    console.log(PERSONAJE_FICTICIO.presentacion());
    //La función de "this" en JavaScript es referirce al objeto que estamos trabajando,en este caso el objeto "persona" y a su propiedad "nombre"
    </code>
    </pre>
            <h2>Definir una clase</h2>
            <p>Las "clases" nos periten crear muchos objetos con la misma extructura,propiedades y funcionalidad:</p>
            <pre>
    <code>
    class TransbordadorEspacial {
    constructor(planeta) {
    this.planeta = planeta;
    }
    }
    var zeus = new TransbordadorEspacial("Jupiter");
    console.log(zeus.planeta);
    /*"constructor" es la función que se va a llamar cuando asignemos a un objeto ese tipo de class."new" es la palabra clave para crear un objeto
    como valor de una var*/ 
    /*Las class en JavaScript siguen una convención específica que es que inician su nombre con mayúscula y también entre palabras inician
    con mayúscula*/ 
    class Mascota {
    constructor(nombre, edad) {
    this.nombre = nombre;
    this.edad = edad;
    }
    }
    var miMascota = new Mascota("Nora", 5);
    console.log(miMascota.nombre);
    console.log(miMascota.edad);
    </code>
    </pre>
            <h2>Getters y Setters</h2>
            <p>Podemos definir funciones en una clase para que al crear un objeto,este tenga todas esas funciones
                asociadas,existen dos funciones específicas que protegen la data del objeto.</p>
            <h3>Getters:</h3>
            <p>Metodos que permiten obtener el valor de una propiedad privada (una propiedad que tenga un guion bajo
                antes de su nombre),es decir,permite acceder al valor indirectamente.</p>
            <h3>Setters:</h3>
            <p>Función que actualiza el valor de una propiedad,utiles para verificar el valor nuevo antes de asignarlo.
            </p>
            <pre>
    <code>
    class libro {
    constructor(autor) {
    this._autor = autor;
    }
    get autor() {
    return this._autor;
    }
    set autor(nuevoAutor) {
    this._autor = nuevoAutor;
    }
    }
    const libro = new libro("anonimo");
    console.log(libro.autor);
    libro.autor = "Marcelo Díaz";
    console.log(libro.autor);
    //Solo utilizar un guion bajo no convierte la variable en privada,es simplemente una convención.
    </code>
    </pre>
            <h2>Exportación para compartir bloques de código</h2>
            <p>En caso de que quisieramos utilizar funciones almacenadas en un archivo,tendriamos que exportalas,para
                ello utilizaremos la palabra clave "export" y la variable donde estan almacenadas estas funciones:</p>
            <pre>
    <code>
    export const add = (x, y) => {
    return x + y;
    }
    //Otra forma sería:
    const add = (x, y) => {
    return x + y;
    }
    export {add};
    /*Puedes exportar varias funciones utilizando la exportación antes del tipo de variable(ejemplo) o poniendolas todas en la declaración de
    exportación(ejemplo 2):*/
    export {add, otherString};
    </code>
    </pre>
            <h2>Reutilización de código mediante importación</h2>
            <p>Este nos permite elegir las partes del archivo/modulo que queremos cargar:</p>
            <pre>
    <code>
    import {add} from './string_functions.JS'
    /* ./ es la ruta relativa del archivo,índica a la importación que busque el archivo string_functions.JS en la misma carpeta
    que el archivo actual*/ 
    // .JS es la extensión del archivo
    //import encuentra add en string_functions.JS,solo importa esta función.
    </code>
    </pre>
            <h2>Utilizar * para importar todo desde un archivo</h2>
            <p>En el caso de que queramos importar todo el contenido de un archivo a otro utilizaremos la sintaxis
                "import * as":</p>
            <pre>
    <code>
    import * as myModule from "./math_functions.JS";
    //Si utilizaramos este tipo de sintaxis,el nombre del archivo va entre comillasdobles.
    /*La declaración import crea un objeto llamado myModule (solo es el nombre de una variable),este contendrá todas las exportaciones que tiene 
    math_functions.JS,si quisieramos utilizar alguna/s funciones que importamos haríamos así:*/
    myModule.add(2, 3);
    myModule.subtract(5, 3);
    //Recordemos que estamos usando funciones que tienen operaciones matemáticas,por eso los números.
    </code>
    </pre>
            <h2>Respaldo de exportación con el valor predeterminado de expostación</h2>
            <p>La sintaxis "export default" nos permite exportar un valor de un archivo(siendo esta comúnmente su
                función):</p>
            <pre>
    <code>
    export default function string(a, b) {
    return a : b;
    }
    //Oh también se puede usar con funciones anonimas:
    export default function(a, b) {
    return a : b;
    }
    /*Esta sintaxis solo se utiliza para declarar un valor alternativo para un archivo/modulo,por ende,solo puede tener un valor como exportación
    predeterminada en cada archivo/modulo.También la "export default" no se puede utilizar con let,const o var*/
    </code>
    </pre>
            <h2>Imortar la exportación predeterminada</h2>
            <p>En caso de que quisieramos importar una exportación predeterminada utilizariamos una import sintaxis que
                no encierra entre llaves el valor importado:</p>
            <pre>
    <code>
    import string from "./math.functions.JS";
    //string es simplemente un nombre de variable para culaquiera que sea la exportación predeterminada del archivo math.functions.JS
    </code>
    </pre>
            <h2>Crear un promesa de J.S</h2>
            <P>La función constructora "promise" toma como argumento una función,con dos parámetros: "resolve" y
                "reject",estos metodos se utilizan para determinar el resultado de la promesa.Su función es hacer una
                promesa para hacer algo,normalmente de forma asincrónica,su sintaxis es:</P>
            <pre>
    <code>
    const stringPromise = new Promise((resolve, reject) => {});
    </code>
    </pre>
            <h2>Completar una promise con resolve y reject</h2>
            <p>En las promesas los parametros "resolve" y "reject" se usan para completar la promesa,"resolve" es si
                queremos que se complete con exito,y "reject" si queremos que falle,ambos toman un argumento:</p>
            <pre>
    <code>
    const makeServerRequest = new Promise((resolve, reject) => {
    let responseFromServer;
    if(responseFromServer) {
    resolve("We got the data");
    } else {
    reject("Data not received");
    }
    });
    /*Las promesas tienen tres estados:
    Pending: sucede cunado no agregamos una forma de completar la promesa,quedando en un estado inicial,es decir,no fue ni cumplida ni rechazada.
    Fulfilled: significa que la promesa se completo con éxito.
    Rejected: significa que la promesa falló. 
    </code>
    </pre>
            <h2>Manejar un a "promise" cumplida con "then"</h2>
            <p>El método "then" programa funciones de devolución de llamada para la finalización de la
                "promise",independientemente de si cumplio o no.Esto dependiendo que controlador se llama(onFulfilled o
                onRejected):</p>
            <pre>
    <code>
    makeServerRequest.then(result => {
    console.log(result);
    });
    //Aquí "result" es el controlador de onFulfilled,ya que "result" proviene del argumento dado al método "resolve"
    </code>
    </pre>
            <h2>Manejo de la "promise" rechazada con "catch"</h2>
            <p>El método "catch" se usa si su "promise" fue rechazada,se ejecuta después de llamar al método "reject" de
                la promesa:</p>
            <pre>
    <code>
    makeServerRequest.cath(error => {
    console.log(error);
    });
    //Dato extra: no borramos el "makeServerRequest.then",simplemente agregamos debajo de el la verción con el método "catch"
    </code>
    </pre>
        </div>
    </main>
    <footer>
        <h3 id="titulo-footer">Contactos:</h3>
        <div class="contactos">
            <p class="texto-final">Instragram: Fraaan.g_m</p>
            <p class="texto-final">Gmail: fgmanuello1@gmail.com</p>
            <p class="texto-final">GitHub: Francisco-G-M</p>
        </div>
    </footer>
</body>

</html>